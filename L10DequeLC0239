from collections import deque
from typing import List

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if not nums or k <= 0:
            return []
        if k == 1:
            return nums[:]  # 每窗只有自己

        dq = deque()      # 存「索引」，對應值嚴格遞減
        res = []

        for right, x in enumerate(nums):
            # 1) 清尾：維持嚴格遞減（小或相等的都沒資格當最大）
            while dq and nums[dq[-1]] <= x:
                dq.pop()
            dq.append(right)

            left = right - k + 1  # 當前窗口左界

            # 2) 清首：隊首若已滑出窗口，丟掉
            if dq[0] < left:
                dq.popleft()


###極簡測試（本地快速 sanity check）###
print(Solution().maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3))  # [3,3,5,5,6,7]
print(Solution().maxSlidingWindow([1], 1))                  # [1]
print(Solution().maxSlidingWindow([9,8,7,6,5], 2))          # [9,8,7,6]
print(Solution().maxSlidingWindow([1,3,1,2,0,5], 3))        # [3,3,2,5]

################################################################################

###heap解法，知道就好###
import heapq

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        res = []
        # Python 預設是 min-heap，所以存 (-值, index)
        heap = []

        for i, num in enumerate(nums):
            # 推入新元素
            heapq.heappush(heap, (-num, i))

            # 當窗口滿足長度 k
            if i >= k - 1:
                # 把超出窗口範圍的元素丟掉
                while heap[0][1] <= i - k:
                    heapq.heappop(heap)
                # 堆頂就是最大值
                res.append(-heap[0][0])

        return res


            # 3) 收答案：窗口長度達到 k 才有輸出
            if left >= 0:
                res.append(nums[dq[0]])
        return res
