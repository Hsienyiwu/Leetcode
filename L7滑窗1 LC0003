###使用set()清楚易懂，但一格一格移除較慢###
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        char_set = set()  # 用來記錄當前視窗內出現過的字元（用 set 檢查重複效率高）
        left = 0          # 視窗左界指標（起始位置）
        max_len = 0       # 用來紀錄目前找到的最長無重複子字串長度

        for right in range(len(s)):  # 右指標遍歷整個字串
            while s[right] in char_set:  # 如果當前字元已存在於視窗中，表示有重複
                char_set.remove(s[left])  # 從視窗中移除左指針指到的字元
                left += 1                 # 左指針右移，縮小視窗，直到移除掉重複字元
            char_set.add(s[right])  # 把目前的字元加入 set，代表它已在視窗中
            max_len = max(max_len, right - left + 1)  # 更新最長長度（目前視窗大小）
        
        return max_len  # 回傳找到的最長無重複子字串的長度

###使用dict()較快，進階作法###

###「HashSet + 雙指針滑動視窗」版本:Python（HashSet 版）###
def lengthOfLongestSubstring(s: str) -> int:
    seen = set()
    l = 0
    ans = 0
    for r, ch in enumerate(s):
        while ch in seen:              # 視窗內已存在 ch，縮小左邊
            seen.remove(s[l])
            l += 1
        seen.add(ch)                   # 把當前字元放入視窗
        ans = max(ans, r - l + 1)      # 更新最長長度
    return ans

###「HashSet + 雙指針滑動視窗」版本:Java（HashSet 版）###
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int n = s.length(), ans = 0;
        int l = 0;
        for (int r = 0; r < n; r++) {
            char ch = s.charAt(r);
            while (set.contains(ch)) {
                set.remove(s.charAt(l));
                l++;
            }
            set.add(ch);
            ans = Math.max(ans, r - l + 1);
        }
        return ans;
    }
}


###包含測試版本的hashset:python版本###
# HashSet + Sliding Window
def lengthOfLongestSubstring_set(s: str) -> int:
    seen = set()
    l = 0
    ans = 0
    for r, ch in enumerate(s):
        while ch in seen:
            seen.remove(s[l])
            l += 1
        seen.add(ch)
        ans = max(ans, r - l + 1)
    return ans


# Dict + Sliding Window（紀錄最後出現位置）
def lengthOfLongestSubstring_dict(s: str) -> int:
    last_idx = {}
    l = 0
    ans = 0
    for r, ch in enumerate(s):
        if ch in last_idx and last_idx[ch] >= l:
            l = last_idx[ch] + 1   # 直接跳過重複字元上一次的位置
        last_idx[ch] = r
        ans = max(ans, r - l + 1)
    return ans


# 測試
def test():
    cases = [
        ("abcabcbb", 3),   # "abc"
        ("bbbbb", 1),      # "b"
        ("pwwkew", 3),     # "wke"
        ("", 0),           # 空字串
        ("au", 2),         # "au"
        ("dvdf", 3),       # "vdf"
    ]

    for s, expected in cases:
        r1 = lengthOfLongestSubstring_set(s)
        r2 = lengthOfLongestSubstring_dict(s)
        print(f"Input: {s:10} | Expected: {expected} | Set: {r1}, Dict: {r2}")

test()

###包含測試版本的hashset:JAVA版本###
import java.util.*;

class Solution {
    // HashSet 寫法
    public int lengthOfLongestSubstring_set(String s) {
        Set<Character> set = new HashSet<>();
        int l = 0, ans = 0;
        for (int r = 0; r < s.length(); r++) {
            char ch = s.charAt(r);
            while (set.contains(ch)) {
                set.remove(s.charAt(l));
                l++;
            }
            set.add(ch);
            ans = Math.max(ans, r - l + 1);
        }
        return ans;
    }

    // Dict 寫法（用 Map 紀錄最後位置）
    public int lengthOfLongestSubstring_dict(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int l = 0, ans = 0;
        for (int r = 0; r < s.length(); r++) {
            char ch = s.charAt(r);
            if (map.containsKey(ch) && map.get(ch) >= l) {
                l = map.get(ch) + 1;
            }
            map.put(ch, r);
            ans = Math.max(ans, r - l + 1);
        }
        return ans;
    }
}




