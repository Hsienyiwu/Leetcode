# LC53 最大子陣列和
def kadane(nums):
    best = cur = nums[0]
    for x in nums[1:]:
        cur = max(x, cur + x)
        best = max(best, cur)
    return best
-------------------------------------------------------------------------------------
# LC918 環狀最大子陣列和
def kadane_circular(nums):
    total = sum(nums)
    max_end = min_end = nums[0]
    max_k = min_k = nums[0]
    for x in nums[1:]:
        max_end = max(x, max_end + x); max_k = max(max_k, max_end)
        min_end = min(x, min_end + x); min_k = min(min_k, min_end)
    return max_k if max_k < total else max_k  # all negative時 total==min_k
    # 實務：return max_k if max_k < 0 else max(max_k, total - min_k)
---------------------------------------------------------------------------------------
# LC152 最大乘積子陣列
def max_product(nums):
    hi = lo = ans = nums[0]
    for x in nums[1:]:
        if x < 0: hi, lo = lo, hi
        hi = max(x, hi * x)
        lo = min(x, lo * x)
        ans = max(ans, hi)
    return ans
--------------------------------------------------------------------------------------
from collections import deque
dq = deque()                # dq = deque([init...], maxlen=可選)
dq.append(x); dq.appendleft(x)
dq.pop(); dq.popleft()
dq[0]; dq[-1]               # 取頭/尾（O(1)）
len(dq); not dq
dq.clear()
dq.rotate(k)                # 右轉k步（左轉用負數）
dq.maxlen                   # 固定長度時自動丟頭
-----------------------------------------------------------------------------------------
模板 A：固定長度滑窗（和/計數/條件）
from collections import deque

def fixed_window_sum(nums, k):
    s = 0; dq = deque()  # 可選：不一定要deque，這裡示範
    res = []
    for i, x in enumerate(nums):
        dq.append(x); s += x
        if len(dq) > k:
            s -= dq.popleft()
        if len(dq) == k:
            res.append(s)
    return res
-------------------------------------------------------------------------------------
模板 B：單調隊列（取每窗最大/最小）— LC239
from collections import deque

def max_sliding_window(nums, k):
    dq = deque()  # 存索引，維持 nums[dq] 單調遞減
    ans = []
    for i, x in enumerate(nums):
        while dq and nums[dq[-1]] <= x:
            dq.pop()
        dq.append(i)
        if dq[0] <= i - k:
            dq.popleft()
        if i >= k - 1:
            ans.append(nums[dq[0]])
    return ans
最小值：把 <= 改成 >= 即可。
--------------------------------------------------------------------------------------
模板 C：前綴和＋單調隊列（最短子陣列和 ≥ K）— LC862
from collections import deque
from itertools import accumulate

def shortest_subarray(nums, K):
    P = [0] + list(accumulate(nums))
    dq = deque()  # 存下標，P 單調遞增
    ans = float('inf')
    for i, cur in enumerate(P):
        while dq and cur - P[dq[0]] >= K:
            ans = min(ans, i - dq.popleft())
        while dq and P[dq[-1]] >= cur:
            dq.pop()
        dq.append(i)
    return ans if ans < float('inf') else -1
----------------------------------------------------------------------------------------
模板 D：滑窗最大差 ≤ limit（同時維護 maxQ/minQ）— LC1438
from collections import deque

def longest_subarray_limit(nums, limit):
    maxQ = deque()  # 值遞增？不，為取max，維持遞減（頭最大）
    minQ = deque()  # 為取min，維持遞增（頭最小）
    L = 0; ans = 0
    for R, x in enumerate(nums):
        while maxQ and maxQ[-1] < x: maxQ.pop()
        while minQ and minQ[-1] > x: minQ.pop()
        maxQ.append(x); minQ.append(x)

        while maxQ[0] - minQ[0] > limit:
            if nums[L] == maxQ[0]: maxQ.popleft()
            if nums[L] == minQ[0]: minQ.popleft()
            L += 1
        ans = max(ans, R - L + 1)
    return ans
--------------------------------------------------------------------------------------------
模板 E：DP＋單調隊列（j ∈ [i−k, i−1] 最大 dp[j]）— LC1425
from collections import deque

def constrained_subset_sum(nums, k):
    n = len(nums)
    dp = [0]*n
    dq = deque()  # 存索引，維持 dp 值遞減（dq[0] 最大）
    for i in range(n):
        best = dp[dq[0]] if dq else 0
        dp[i] = nums[i] + max(0, best)
        while dq and dp[dq[-1]] <= dp[i]:
            dq.pop()
        dq.append(i)
        if dq[0] <= i - k:
            dq.popleft()
    return max(dp)
-----------------------------------------------------------------------------------------------
常見坑位

@存「索引」還是「值」要一致（LC239/862/1425通常存索引）。

@視窗左界推進時，要同步把「過期索引」從頭部彈出。

@<= / >= 的等號影響穩定性（避免相等時形成不必要堆疊）。

@全為負值情境（LC918/LC152）要特別小心初始化。

#################################################################################################
DP ＋ Kadane 本來就是整個演算法世界的核心地基。
你現在把它們吃透，後面 LC 1425、918、152、239、862 都會變成「同一首歌不同段」。

建議你筆記再分類小一點會更好吸收：
1️⃣ DP 通則表：狀態、轉移、初始化、邊界。
2️⃣ Kadane 家族：53 基礎→918 環形→152 乘積→1425 限制距離。
3️⃣ 共通模板：dp[i]=nums[i]+max(0, best_in_window)。

等你這兩條線都熟了，整條 「DP↔Sliding Window↔Deque」 就能一氣呵成。

