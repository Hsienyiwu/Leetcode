###wrong answer but follow templete###
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrack(start, path):
            res.append(path.copy()) #關鍵!記錄當前子集
            for i in range(start, len(nums)):
                path.append(nums[i]) #選擇 nums[i]
                backtrack(i + 1, path) #探索下一層
                path.pop() #撤銷選擇(回溯)
                backtrack(0, [])
                return res


###correct answer of transformed 1###
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrack(index, path):
            if index == len(nums):
                res.append(path.copy())

                return
            #不選當前數字
            backtrack(index + 1, path)
            #選當前數字
            path.append(nums[index])
            backtrack(index + 1, path) 
            path.pop()
        backtrack(0, [])
        return res
###summary for correct answer of transformed###
class Solution: #類名應為大寫開頭
  def subsets(self, nums):
     res = []  #存儲所有子集的結果
    #回溯題型變形開始
     def backtrack(index, path): #定義回溯函數，index表示當前的數字索引，path表示當前路徑
      if index == len(nums): #終止條件:處理完所有數字
        res.append(path.copy()) #將當前路徑(子集)加入結果
        return  #控制函數流程(不再繼續函數的後續執行)
      #不選當前數字
      backtrack(index + 1, path) 
      #選當前數字
      path.append(nums[index])  
      backtrack(index + 1, path) 
      path.pop()     #回溯，移除當前數字 
     backtrack(0, []) #從索引0和空路徑開始
     return res #終止函數執行
#測試範例
sol = Solution()
print(sol.subsets([1,2,3]))

_________________________________________________________________________________________________
output=> [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
