from collections import deque
from typing import List

class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        maxdq = deque()  # indices; values decreasing
        mindq = deque()  # indices; values increasing
        left = 0
        ans = 0

        for right, x in enumerate(nums):
            # push to maxdq: keep decreasing
            while maxdq and nums[maxdq[-1]] < x:
                maxdq.pop()
            maxdq.append(right)

            # push to mindq: keep increasing
            while mindq and nums[mindq[-1]] > x:
                mindq.pop()
            mindq.append(right)

            # shrink while violates limit
            while nums[maxdq[0]] - nums[mindq[0]] > limit:
                if maxdq[0] == left:
                    maxdq.popleft()
                if mindq[0] == left:
                    mindq.popleft()
                left += 1

            # update answer
            ans = max(ans, right - left + 1)

        return ans

#########################################################################

from collections import deque
from typing import List

def longestSubarray(nums: List[int], limit: int) -> int:
    # 口訣：先更新兩 deque → 檢查違規就收縮 → 更新答案
    maxdq = deque()  # 單調遞減：存索引，隊首是當前窗口最大值的索引
    mindq = deque()  # 單調遞增：存索引，隊首是當前窗口最小值的索引

    left = 0
    ans = 0

    for right, x in enumerate(nums):
        # 更新 maxdq：把尾端比 x 小的通通彈掉，維持遞減
        while maxdq and nums[maxdq[-1]] < x:
            maxdq.pop()
        maxdq.append(right)

        # 更新 mindq：把尾端比 x 大的通通彈掉，維持遞增
        while mindq and nums[mindq[-1]] > x:
            mindq.pop()
        mindq.append(right)

        # 若窗口違規（最大 - 最小 > limit），就收縮左邊直到合規
        while nums[maxdq[0]] - nums[mindq[0]] > limit:
            # 左指針越界就同步彈頭
            if maxdq[0] == left:
                maxdq.popleft()
            if mindq[0] == left:
                mindq.popleft()
            left += 1

        # 更新答案（當前合法窗口長度）
        ans = max(ans, right - left + 1)

    return ans

############################################################################################################
LC1438《Longest Continuous Subarray With Absolute Diff ≤ Limit》是滑窗 + 單調 deque 的經典題。簡答模式快速回顧：

思路摘要

題意：找最長子陣列，使得 max - min ≤ limit。

解法核心：滑動窗口維持當前區間內的最大值、最小值。

資料結構：兩個單調 deque

maxdq：單調遞減 → 頭是最大值

mindq：單調遞增 → 頭是最小值
--------------------------------------------------------------------------------------------------------------
步驟模板
from collections import deque

def longestSubarray(nums, limit):
    maxdq, mindq = deque(), deque()
    left = 0
    ans = 0
    for right, x in enumerate(nums):
        # 維持單調性
        while maxdq and x > maxdq[-1]:
            maxdq.pop()
        while mindq and x < mindq[-1]:
            mindq.pop()
        maxdq.append(x)
        mindq.append(x)

        # 檢查條件
        while maxdq[0] - mindq[0] > limit:
            if nums[left] == maxdq[0]:
                maxdq.popleft()
            if nums[left] == mindq[0]:
                mindq.popleft()
            left += 1

        ans = max(ans, right - left + 1)
    return ans
-------------------------------------------------------------------------------------------------------------------------
心法

規則：窗口只收縮到條件再次成立為止。

對稱：最大最小兩條 deque 同步維護。

模板：while max-min>limit: shrink left。

